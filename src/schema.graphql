type Query {
    HostTags (
        hostFilter: HostFilter,
        filter: TagAggregationFilter,
        limit: Int = 10,
        offset: Int = 0,
        order_by: HOST_TAGS_ORDER_BY = count,
        order_how: ORDER_DIR = DESC
    ): HostTags
}

input HostFilter {
    id: FilterString
}

input FilterString {
    eq: String
}

enum ORDER_DIR {
    ASC,
    DESC
}

enum HOST_TAGS_ORDER_BY {
    tag,
    count
}

input TagAggregationFilter {
    """
    Limits the aggregation to tags that match the given search term.
    The search term is a regular exression that operates on a string representation of a tag.
    The string representation has a form of "namespace/key=value" i.e. the segments are concatenated together using "=" and "/", respectively.
    There is no expecing of the control characters in the segments.
    As a result, "=" and "/" appear in every tag.
    """
    search: FilterStringWithRegex
}

"""
String field filter that allows filtering based on exact match or using regular expression.
"""
input FilterStringWithRegex {
    """
    Compares the document field with the provided value.
    If \`null\` is provided then documents where the given field does not exist are returned.
    """
    eq: String

    """
    Matches the document field against the provided regular expression.
    """
    regex: String
}

type HostTags {
    data: [TagInfo]!
    meta: CollectionMeta!
}

type CollectionMeta {
    "number of returned results"
    count: Int!
    "total number of entities matching the query"
    total: Int!
}

type StructuredTag {
    namespace: String,
    key: String!,
    value: String
}

type Tags {
    data: [StructuredTag]!
    meta: CollectionMeta!
}

type TagInfo {
    tag: StructuredTag!
    count: Int!
}
